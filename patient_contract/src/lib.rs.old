use cosmwasm_std::{DepsMut, Deps, Env, MessageInfo, Response, StdResult, StdError, Addr, to_binary, Binary};
use crate::msg::{ExecuteMsg, QueryMsg};
use crate::state::{Patient, PATIENTS, ACCESS, PATIENT_COUNT};
use cw_storage_plus::Item;

mod msg;
mod state;

use crate::msg::*;
use crate::state::*;

#[cfg_attr(not(feature = "library"), cosmwasm_std::entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: crate::msg::InstantiateMsg,
) -> StdResult<Response> {
    PATIENT_COUNT.save(deps.storage, &0)?;
    Ok(Response::new().add_attribute("method", "instantiate"))
}

pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> StdResult<Response> {
    match msg {
        ExecuteMsg::CreatePatient { name, age, disease } => execute_create_patient(deps, info, name, age, disease),
        ExecuteMsg::GrantAccess { patient_id, addr } => execute_grant_access(deps, info, patient_id, addr),
        ExecuteMsg::RevokeAccess { patient_id, addr } => execute_revoke_access(deps, info, patient_id, addr),
    }
}

fn execute_create_patient(
    deps: DepsMut,
    info: MessageInfo,
    name: String,
    age: u8,
    disease: String,
) -> StdResult<Response> {
    let mut patient_id = PATIENT_COUNT.may_load(deps.storage)?.unwrap_or(0);
    patient_id += 1;

    let patient = Patient { name, age, disease };
    PATIENTS.save(deps.storage, patient_id, &patient)?;
    ACCESS.save(deps.storage, patient_id, &vec![info.sender.clone()])?; // Créateur a accès
    PATIENT_COUNT.save(deps.storage, &patient_id)?;

    Ok(Response::new()
        .add_attribute("action", "create_patient")
        .add_attribute("patient_id", patient_id.to_string()))
}

fn execute_grant_access(
    deps: DepsMut,
    info: MessageInfo,
    patient_id: u64,
    addr: String,
) -> StdResult<Response> {
    let mut access = ACCESS.load(deps.storage, patient_id)?;
    let new_addr = deps.api.addr_validate(&addr)?;

    if !access.contains(&info.sender) {
        return Err(StdError::generic_err("Vous n'êtes pas autorisé à gérer cet accès"));
    }

    if !access.contains(&new_addr) {
        access.push(new_addr);
        ACCESS.save(deps.storage, patient_id, &access)?;
    }

    Ok(Response::new().add_attribute("action", "grant_access"))
}

fn execute_revoke_access(
    deps: DepsMut,
    info: MessageInfo,
    patient_id: u64,
    addr: String,
) -> StdResult<Response> {
    let mut access = ACCESS.load(deps.storage, patient_id)?;
    let remove_addr = deps.api.addr_validate(&addr)?;

    if !access.contains(&info.sender) {
        return Err(StdError::generic_err("Vous n'êtes pas autorisé à gérer cet accès"));
    }

    access.retain(|a| a != &remove_addr);
    ACCESS.save(deps.storage, patient_id, &access)?;

    Ok(Response::new().add_attribute("action", "revoke_access"))
}

pub fn query(deps: Deps, _env: Env, msg: QueryMsg, requester: Addr) -> StdResult<Binary> {
    match msg {
        QueryMsg::GetPatient { patient_id } => to_binary(&query_get_patient(deps, patient_id, requester)?),
    }
}

fn query_get_patient(deps: Deps, patient_id: u64, requester: Addr) -> StdResult<Patient> {
    let patient = PATIENTS.load(deps.storage, patient_id)?;
    let access_list = ACCESS.load(deps.storage, patient_id)?;

    if !access_list.contains(&requester) {
        return Err(StdError::generic_err("Accès non autorisé"));
    }

    Ok(patient)
}